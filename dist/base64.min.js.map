{"version":3,"file":"base64.min.js","sources":["../src/atob.js","../src/digits.js","../src/btoa.js","../src/utf8.js","../src/base64.js"],"sourcesContent":["\nimport b64 from './digits';\n\n/*globals atob, Buffer*/\n\n// Modern browsers have atob and btoa defined\nexport const atobBrowser = typeof atob == 'function' && atob;\n\n// Node.js\nexport function atobNode(data) { return Buffer.from(data, 'base64').toString('binary'); }\n\n// Out custom implementation (polyfill)\nvar b64i;\nconst wsReg = /[\\t\\n\\r\\x20\\x0C]+/g;\nconst chr = String.fromCharCode;\n// if ( typeof chr.bind == 'function' ) chr = chr.bind(String);\n\n/**\n * Decodes UTF8 or byte string\n *\n * @param {String} data\n */\nexport function atobJS(data) {\n    if (!data) return data;\n    data = String(data).replace(wsReg, '');\n\n    var o1, o2, o3, h1, h2, h3, h4, bits\n    ,   l = data.length\n    ,   i = 0\n    ,   ac = 0\n    ,   dec = ''\n    ,   tmp_arr = []\n    ;\n    if(b64i == undefined) {\n        b64i = {};\n        for(var j = 0, bl = b64.length; j < bl; j++) b64i[b64.charAt(j)] = j;\n    }\n\n    do {\n        // unpack four hexets into three octets using index points in b64\n        h1 = b64i[data.charAt(i++)];\n        h2 = b64i[data.charAt(i++)];\n        h3 = b64i[data.charAt(i++)];\n        h4 = b64i[data.charAt(i++)];\n\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n            tmp_arr[ac++] = chr(o1);\n        }\n        else if (h4 == 64) {\n            tmp_arr[ac++] = chr(o1, o2);\n        }\n        else {\n            tmp_arr[ac++] = chr(o1, o2, o3);\n        }\n    } while (i < l);\n\n    dec = tmp_arr.join('');\n\n    return dec.replace(/\\0+$/, '');\n}\n\nconst _atob = atobBrowser || typeof Buffer == 'function' && atobNode || atobJS;\n\nexport default _atob;\n","\nexport default 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n","\nimport b64 from './digits';\n\n/*globals btoa, Buffer*/\n\n// Modern browsers have atob and btoa defined\nexport const btoaBrowser = typeof btoa == 'function' && btoa;\n\n// Node.js\nexport function btoaNode(data) { return Buffer.from(data, 'binary').toString('base64'); }\n\n// Out custom implementation (polyfill)\n\n/**\n * Encodes UTF8 or byte string\n *\n * @param {String} data\n */\nexport function btoaJS(data) {\n    if (!data) return data;\n\n    var o1, o2, o3, h1, h2, h3, h4, bits\n    ,   i = 0\n    ,   ac = 0\n    ,   enc = ''\n    ,   tmp_arr = []\n    ;\n    do {\n        // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    var r = data.length % 3;\n\n    return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n}\n\nconst _btoa = btoaBrowser || typeof Buffer == 'function' && btoaNode || btoaJS;\n\nexport default _btoa;\n","\n/*globals unescape, escape, decodeURIComponent, encodeURI*/\n\n/// Encode multi-byte into UTF-8 string\nexport function utf8Encode(str) { return unescape( encodeURI( str ) ); }\n\n/// Decode UTF-8 string to multi-byte string\nexport function utf8Decode(str) { return decodeURIComponent( escape( str ) ); }\n","/**\n*  Base64 string encoding and decoding utility.\n*\n*  play @ https://duzun.me/playground/encode#base64Encode=Test%20String%20\n*\n*  original of _btoa and _atob by: Tyler Akins (http://rumkin.com)\n*\n*\n*  @license MIT\n*  @version 2.2.0\n*  @author Dumitru Uzun (DUzun.Me)\n*/\n\nexport const VERSION = '2.2.0';\n\nimport _atob from './atob';\nimport _btoa from './btoa';\nimport { utf8Encode, utf8Decode } from './utf8';\n\n\n// Decodes byte-string - 8bit per char - either btoa()'s return or byteUrlEncode()'s return\nexport function byteDecode(data) {\n    let ret = data;\n    if(ret) {\n        ret = _atob(String(ret)\n            .replace(/_/g, '/')\n            .replace(/-/g, '+'))\n        ;\n    }\n    return ret;\n}\n\n// Encode byte-string - 8bit per char - used for binary data\nexport { _btoa as byteEncode };\n\n// Encodes multi-byte string as utf8 (common in JS)\nexport function mbEncode(data) {\n    if(!data) return data;\n    return _btoa(utf8Encode(data));\n}\n\n// Decodes to multi-byte string if utf8-encoded\nexport function mbDecode(data, force_utf8) {\n    let ret = byteDecode(data);\n    if(ret) {\n        if(force_utf8) {\n            return utf8Decode(ret);\n        }\n        else {\n            try {\n                ret = utf8Decode(ret);\n            } catch(err) {}\n        }\n    }\n    return ret;\n}\n\n// Encode for URL\nexport function byteUrlEncode(data) {\n    let ret = _btoa(data);\n    return ret && ret.replace(/\\=+$/, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\n// Decode from byteUrlEncode()\nexport function byteUrlDecode(data, force_utf8) {\n    let ret = data;\n    if(ret) {\n        ret += '==='.substr(0, 3-(ret.length+3)%4);\n        ret = byteDecode(ret, force_utf8);\n    }\n    return ret;\n}\n\n// Encode as base64 a multi-byte string as utf8 for URL\nexport function mbUrlEncode(data) {\n    if(!data) return data;\n    let ret = utf8Encode(data);\n    return byteUrlEncode(ret);\n}\n\n// Decode base64 of utf8 encoded text to multi-byte string\nexport function mbUrlDecode(data) {\n    let ret = byteUrlDecode(data);\n    return ret && utf8Decode(ret);\n}\n\n\n// multi-byte string - common JS String - used for text data - get encoded/decoded to/from utf8\nexport { mbEncode as encode };\nexport { mbDecode as decode };\n\n// multi-byte string - common JS String - used for text data - get encoded/decoded to/from utf8 for URL\nexport { mbUrlEncode as urlEncode };\nexport { mbUrlDecode as urlDecode };\n\nexport { utf8Encode as mb2utf8 };\nexport { utf8Decode as utf82mb };\n\nexport { _atob as _atob };\nexport { _btoa as _btoa };\n\n// Make sure atob and btoa exists in the environment\nexport function polyfill(global) {\n    if ( global ) {\n        if (typeof global.atob == 'undefined') {\n            global.atob = _atob;\n        }\n        if (typeof global.btoa == 'undefined') {\n            global.btoa = _btoa;\n        }\n    }\n    else {\n        const no_atob = typeof atob == 'undefined';\n        const no_btoa = typeof btoa == 'undefined';\n\n        if (no_atob || no_btoa) {\n            global = typeof window == 'undefined' ? typeof global == 'undefined' ? typeof self == 'undefined' ? this || new Function('return this')() : self : global : window;\n\n            if (no_atob) {\n                global.atob = _atob;\n            }\n            if (no_btoa) {\n                global.btoa = _btoa;\n            }\n        }\n    }\n}\n\nexport function bindProto(__) {\n    const __ex = typeof Object.defineProperty == 'function'\n          ? (name, func/*, proto*/) => {\n              Object.defineProperty(/*proto||*/__, name, {\n                  value: func,\n                  configurable: true,\n                  enumerable: false,\n                  writeable: true\n              });\n          }\n          : (name, func/*, proto*/) => {\n              // Take care with (for ... in) on strings!\n              (/*proto||*/__)[name] = func;\n          }\n    ;\n\n    __ex('base64ByteEncode', function () { return _btoa(this); });\n    __ex('base64ByteDecode', function () { return byteDecode(this); });\n\n    __ex('base64Encode', function () { return mbEncode(this); });\n    __ex('base64Decode', function () { return mbDecode(this); });\n\n    __ex('base64ByteUrlEncode', function () { return byteUrlEncode(this); });\n    __ex('base64ByteUrlDecode', function () { return byteUrlDecode(this); });\n\n    __ex('base64UrlEncode', function () { return mbUrlEncode(this); });\n    __ex('base64UrlDecode', function () { return mbUrlDecode(this); });\n}\n\n// Add String.prototype methods:\n// bindProto(String.prototype);\n"],"names":["b64i","atobBrowser","atob","wsReg","chr","String","fromCharCode","_atob","Buffer","data","from","toString","o1","o2","o3","h3","h4","bits","l","replace","length","i","ac","tmp_arr","undefined","j","bl","b64","charAt","join","_btoa","btoa","h1","h2","enc","charCodeAt","r","slice","utf8Encode","str","unescape","encodeURI","utf8Decode","decodeURIComponent","escape","byteDecode","ret","mbEncode","mbDecode","force_utf8","err","byteUrlEncode","byteUrlDecode","substr","mbUrlEncode","mbUrlDecode","__","__ex","Object","defineProperty","name","func","value","configurable","enumerable","writeable","this","global","no_atob","no_btoa","window","self","Function"],"mappings":"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"}