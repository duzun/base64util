{"version":3,"file":"base64.min.js","sources":["digits.js","atob.js","btoa.js","utf8.js","base64.js"],"sourcesContent":["\nexport default 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n","\nimport b64 from './digits';\n\nvar _atob;\n\n/*globals atob, Buffer*/\n\n// Modern browsers have atob and btoa defined\nif ( typeof atob == 'function' ) {\n    _atob = atob;\n}\nelse\n// Node.js\nif ( typeof Buffer == 'function' ) {\n    _atob = (data) => new Buffer(data, 'base64').toString('binary');\n}\n// Out custom implementation (polyfill)\nelse {\n    var b64i;\n    const wsReg = /[\\t\\n\\r\\x20\\x0C]+/g;\n\n    const chr = String.fromCharCode;\n    // if ( typeof chr.bind == 'function' ) chr = chr.bind(String);\n\n    // Decodes UTF8 or byte string\n    _atob = function _atob(data) {\n        if (!data) return data;\n        data = String(data).replace(wsReg, '');\n\n        var o1, o2, o3, h1, h2, h3, h4, bits\n        ,   l = data.length\n        ,   i = 0\n        ,   ac = 0\n        ,   dec = ''\n        ,   tmp_arr = []\n        ;\n        if(b64i == undefined) {\n            b64i = {};\n            for(var j = 0, bl = b64.length; j < bl; j++) b64i[b64.charAt(j)] = j;\n        }\n\n        do {\n            // unpack four hexets into three octets using index points in b64\n            h1 = b64i[data.charAt(i++)];\n            h2 = b64i[data.charAt(i++)];\n            h3 = b64i[data.charAt(i++)];\n            h4 = b64i[data.charAt(i++)];\n\n            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n            o1 = bits >> 16 & 0xff;\n            o2 = bits >> 8 & 0xff;\n            o3 = bits & 0xff;\n\n            if (h3 == 64) {\n                tmp_arr[ac++] = chr(o1);\n            }\n            else if (h4 == 64) {\n                tmp_arr[ac++] = chr(o1, o2);\n            }\n            else {\n                tmp_arr[ac++] = chr(o1, o2, o3);\n            }\n        } while (i < l);\n\n        dec = tmp_arr.join('');\n\n        return dec.replace(/\\0+$/, '');\n    };\n}\n\nexport default _atob;\n","\nimport b64 from './digits';\n\nvar _btoa;\n\n/*globals btoa, Buffer*/\n\n// Modern browsers have atob and btoa defined\nif ( typeof btoa == 'function' ) {\n    _btoa = btoa;\n}\nelse\n// Node.js\nif ( typeof Buffer == 'function' ) {\n    _btoa = (data) => new Buffer(data, 'binary').toString('base64');\n}\n// Out custom implementation (polyfill)\nelse {\n    // Encodes UTF8 or byte string\n    _btoa = function _btoa(data) {\n        if (!data) return data;\n\n        var o1, o2, o3, h1, h2, h3, h4, bits\n        ,   i = 0\n        ,   ac = 0\n        ,   enc = ''\n        ,   tmp_arr = []\n        ;\n        do {\n            // pack three octets into four hexets\n            o1 = data.charCodeAt(i++);\n            o2 = data.charCodeAt(i++);\n            o3 = data.charCodeAt(i++);\n\n            bits = o1 << 16 | o2 << 8 | o3;\n\n            h1 = bits >> 18 & 0x3f;\n            h2 = bits >> 12 & 0x3f;\n            h3 = bits >> 6 & 0x3f;\n            h4 = bits & 0x3f;\n\n            // use hexets to index into b64, and append result to encoded string\n            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n        } while (i < data.length);\n\n        enc = tmp_arr.join('');\n\n        var r = data.length % 3;\n\n        return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n    };\n}\n\nexport default _btoa;\n","\n/*globals unescape, escape*/\n\n/// Encode multi-byte into UTF-8 string\nexport const utf8Encode = (str) => unescape( encodeURI( str ) );\n\n/// Decode UTF-8 string to multi-byte string\nexport const utf8Decode = (str) => decodeURIComponent( escape( str ) );\n","/**\n*  Base64 string encoding and decoding utility.\n*\n*  play @ https://duzun.me/playground/encode#base64Encode=Test%20String%20\n*\n*  original of _btoa and _atob by: Tyler Akins (http://rumkin.com)\n*\n*\n*  @license MIT\n*  @version 2.0.0\n*  @umd AMD, Browser, CommonJs\n*  @author Dumitru Uzun (DUzun.Me)\n*/\n\nexport const VERSION = '2.0.0';\n\nimport _atob from './atob';\nimport _btoa from './btoa';\nimport { utf8Encode, utf8Decode } from './utf8';\n\n\n// Decodes byte-string - 8bit per char - either btoa()'s return or byteUrlEncode()'s return\nexport function byteDecode(data) {\n    let ret = data;\n    if(ret) {\n        ret = _atob(String(ret)\n            .replace(/_/g, '/')\n            .replace(/-/g, '+'))\n        ;\n    }\n    return ret;\n}\n\n// Encode byte-string - 8bit per char - used for binary data\nexport { _btoa as byteEncode };\n\n// Encodes multi-byte string as utf8 (common in JS)\nexport function mbEncode(data) {\n    if(!data) return data;\n    return _btoa(utf8Encode(data));\n}\n\n// Decodes to multi-byte string if utf8-encoded\nexport function mbDecode(data, force_utf8) {\n    let ret = byteDecode(data);\n    if(ret) {\n        if(force_utf8) {\n            return utf8Decode(ret);\n        }\n        else {\n            try {\n                ret = utf8Decode(ret);\n            } catch(err) {}\n        }\n    }\n    return ret;\n}\n\n// Encode for URL\nexport function byteUrlEncode(data) {\n    let ret = _btoa(data);\n    return ret && ret.replace(/\\=+$/, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\n// Decode from byteUrlEncode()\nexport function byteUrlDecode(data, force_utf8) {\n    let ret = data;\n    if(ret) {\n        ret += '==='.substr(0, 3-(ret.length+3)%4);\n        ret = byteDecode(ret, force_utf8);\n    }\n    return ret;\n}\n\n// Encode as base64 a multi-byte string as utf8 for URL\nexport function mbUrlEncode(data) {\n    if(!data) return data;\n    let ret = utf8Encode(data);\n    return byteUrlEncode(ret);\n}\n\n// Decode base64 of utf8 encoded text to multi-byte string\nexport function mbUrlDecode(data) {\n    let ret = byteUrlDecode(data);\n    return ret && utf8Decode(ret);\n}\n\n\n// multi-byte string - common JS String - used for text data - get encoded/decoded to/from utf8\nexport { mbEncode as encode };\nexport { mbDecode as decode };\n\n// multi-byte string - common JS String - used for text data - get encoded/decoded to/from utf8 for URL\nexport { mbUrlEncode as urlEncode };\nexport { mbUrlDecode as urlDecode };\n\nexport { utf8Encode as mb2utf8 };\nexport { utf8Decode as utf82mb };\n\nexport { _atob as _atob };\nexport { _btoa as _btoa };\n\n// Make sure atob and btoa exists in the environment\nexport function polyfill(global) {\n    if ( !global ) {\n        global = typeof window == 'undefined' ? typeof global == 'undefined' ? typeof self == 'undefined' ? this : self : global : window;\n    }\n    if ( global ) {\n        if ( typeof atob == 'undefined' ) {\n            global.atob = _atob;\n        }\n        if ( typeof btoa == 'undefined' ) {\n            global.btoa = _btoa;\n        }\n    }\n}\n\nexport function bindProto(__) {\n    const __ex = typeof Object.defineProperty == 'function'\n          ? (name, func/*, proto*/) => {\n              Object.defineProperty(/*proto||*/__, name, {\n                  value: func,\n                  configurable: true,\n                  enumerable: false,\n                  writeable: true\n              });\n          }\n          : (name, func/*, proto*/) => {\n              // Take care with (for ... in) on strings!\n              (/*proto||*/__)[name] = func;\n          }\n    ;\n\n    __ex('base64ByteEncode', function () { return _btoa(this); });\n    __ex('base64ByteDecode', function () { return byteDecode(this); });\n\n    __ex('base64Encode', function () { return mbEncode(this); });\n    __ex('base64Decode', function () { return mbDecode(this); });\n\n    __ex('base64ByteUrlEncode', function () { return byteUrlEncode(this); });\n    __ex('base64ByteUrlDecode', function () { return byteUrlDecode(this); });\n\n    __ex('base64UrlEncode', function () { return mbUrlEncode(this); });\n    __ex('base64UrlDecode', function () { return mbUrlDecode(this); });\n}\n\n// Add String.prototype methods:\nbindProto(String.prototype);\n"],"names":["atob","Buffer","data","toString","b64i","wsReg","chr","String","fromCharCode","o1","o2","o3","h3","h4","bits","l","replace","length","i","ac","tmp_arr","undefined","j","bl","b64","charAt","join","_atob","btoa","h1","h2","enc","charCodeAt","r","slice","utf8Encode","str","unescape","encodeURI","utf8Decode","decodeURIComponent","escape","byteDecode","ret","mbEncode","_btoa","mbDecode","force_utf8","err","byteUrlEncode","byteUrlDecode","substr","mbUrlEncode","mbUrlDecode","bindProto","__","__ex","Object","defineProperty","name","func","this","prototype","global","window","self"],"mappings":"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"}